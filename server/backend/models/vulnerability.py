from django.conf import settings
from django.core.exceptions import ObjectDoesNotExist
from django.core.validators import ValidationError
from django.db import models

from .project import Project


class Severity(models.IntegerChoices):
    """Choices for ``Finding`` and ``Vulnerability`` severities"""

    INFORMATIONAL = 0, "Informational"
    LOW = 1, "Low"
    MEDIUM = 2, "Medium"
    HIGH = 3, "High"
    CRITICAL = 4, "Critical"


class BaseVulnerability(models.Model):
    vulnerability_id = models.CharField(max_length=254)
    severity = models.PositiveSmallIntegerField(choices=Severity.choices)
    date_created = models.DateTimeField(auto_now_add=True)
    date_updated = models.DateTimeField(auto_now=True)
    name = models.CharField(max_length=128)
    description = models.TextField()
    recommendation = models.TextField()
    remediation = models.CharField(max_length=1024, blank=True)
    cwe = models.ForeignKey("backend.CWE", on_delete=models.SET_NULL, null=True)

    class Meta:
        abstract = True


class VulnerabilityTemplateManager(models.Manager):
    def get_by_natural_key(self, vulnerability_id):
        return self.get(vulnerability_id=vulnerability_id)


class VulnerabilityTemplate(BaseVulnerability):
    objects = VulnerabilityTemplateManager()
    vulnerability_id = models.CharField(max_length=254, unique=True)

    class Meta:
        ordering = ["-vulnerability_id"]
        verbose_name = "Vulnerability Template"
        verbose_name_plural = "Vulnerability Templates"

    def __str__(self):
        return self.vulnerability_id

    @property
    def natural_key(self):
        return self.vulnerability_id

    def get_localized(self, language):
        qs = self.translations.filter(language=language)
        if not qs.exists():
            return self
        return qs.get()


class TranslationQuerySet(models.QuerySet):
    def for_language(self, lang_code):
        return self.filter(language=lang_code)

    def for_template(self, template):
        return self.filter(template=template)


class VulnerabilityTemplateTranslation(models.Model):
    objects = TranslationQuerySet.as_manager()
    language = models.CharField(choices=settings.LANGUAGES, max_length=4)
    template = models.ForeignKey('backend.VulnerabilityTemplate', on_delete=models.CASCADE,
                                 related_name='translations')
    name = models.CharField(max_length=128)
    description = models.TextField()
    recommendation = models.TextField()
    remediation = models.CharField(max_length=1024)

    class Meta:
        unique_together = [
            ('language', 'template')
        ]

    def save(self, *args, **kwargs):
        self.full_clean()
        return super().save(*args, **kwargs)

    def clean(self):
        if self.language == 'en':
            raise ValidationError({'language': 'Invalid choice'})
        return super().clean()


class ProjectVulnerabilityQuerySet(models.QuerySet):
    def for_project(self, project):
        return self.filter(project=project)


class ProjectVulnerabilityManager(models.Manager):
    def create_from_template(self, project, template):
        vulnerability = self.from_template(project, template)
        vulnerability.save()
        return vulnerability

    def from_template(self, project, template):
        fields = {
            f.name: getattr(template, f.name) for f in VulnerabilityTemplate._meta.fields
        }
        fields["project"] = project
        fields["template"] = template
        localized = template.get_localized(project.language)
        fields['name'] = localized.name
        fields['description'] = localized.description
        fields['recommendation'] = localized.recommendation
        fields['remediation'] = localized.remediation
        return self.model(**fields)

    def get_by_natural_key(self, project_id, vulnerability_id):
        return self.get(project_id=project_id, vulnerability_id=vulnerability_id)

    def get_or_create_from_key(self, project_id, vulnerability_id):
        try:
            return self.get_by_natural_key(project_id, vulnerability_id)
        except ObjectDoesNotExist:
            return self.create_from_key(project_id, vulnerability_id)

    def validate_key(self, pentest, vuln_id):
        try:
            self.get_by_natural_key(pentest, vuln_id)
            return True
        except ObjectDoesNotExist:
            try:
                VulnerabilityTemplate.objects.get_by_natural_key(vuln_id)
                return True
            except ObjectDoesNotExist:
                return False

    def create_from_key(self, project_id, vuln_id):
        template = VulnerabilityTemplate.objects.get_by_natural_key(vuln_id)
        project = Project.objects.get(pk=project_id)
        return self.create_from_template(project, template)


class ProjectVulnerability(BaseVulnerability):
    objects = ProjectVulnerabilityManager.from_queryset(ProjectVulnerabilityQuerySet)()
    project = models.ForeignKey("backend.Project", on_delete=models.CASCADE)
    template = models.ForeignKey(
        "backend.VulnerabilityTemplate",
        on_delete=models.SET_NULL,
        null=True,
        blank=True,
    )

    class Meta:
        unique_together = [("project", "vulnerability_id"), ("project", "name")]
        verbose_name = "Project Vulnerability"
        verbose_name_plural = "Project Vulnerabilities"
        ordering = ["-severity"]

    def __str__(self):
        return self.vulnerability_id

    @property
    def natural_key(self):
        return self.project.pk, self.vulnerability_id
