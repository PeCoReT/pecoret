from django.conf import settings
from drf_spectacular.utils import extend_schema, OpenApiParameter, extend_schema_view
from rest_framework import status
from rest_framework.decorators import action
from rest_framework.filters import SearchFilter
from rest_framework.response import Response

from backend import models
from backend.api.serializers.vulnerability import (
    VulnerabilityTemplateSerializer,
    ProjectVulnerabilitySerializer,
    VulnerabilityTemplateTranslationSerializer,
    VulnerabilityTemplateTranslationPatchSerializer
)
from pecoret.core import permissions
from pecoret.core.utils import schema
from pecoret.core.viewsets import PeCoReTModelViewSet


@schema.extend_viewset_schema(tags=['Vulnerability Templates'], verbose_name='vulnerability template')
class VulnerabilityTemplateViewSet(PeCoReTModelViewSet):
    queryset = models.VulnerabilityTemplate.objects.order_by("vulnerability_id")
    search_fields = ["name", "vulnerability_id"]
    filterset_class = None
    api_scope = "scope_knowledgebase"
    serializer_class = VulnerabilityTemplateSerializer
    permission_classes = [
        permissions.GroupPermission(
            read_write_groups=[
                permissions.Groups.GROUP_PENTESTER
            ],
            read_only_groups=[
                permissions.Groups.GROUP_MANAGEMENT
            ],
        )
    ]

    @extend_schema(tags=['Vulnerability Templates'], operation_id='Create a template translation')
    @action(methods=['post'], detail=True, url_path='translations',
            serializer_class=VulnerabilityTemplateTranslationSerializer)
    def translation_create(self, request, *args, **kwargs):
        template = self.get_object()
        serializer = VulnerabilityTemplateTranslationSerializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save(template=template)
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    @extend_schema(
        parameters=[OpenApiParameter(name='language', type=str, location=OpenApiParameter.PATH)],
        tags=['Vulnerability Templates'], operation_id='Get a specific template translation')
    @action(methods=['get', 'patch', 'delete'], detail=True, url_path='translations/(?P<language>[^/.]+)',
            serializer_class=VulnerabilityTemplateTranslationSerializer)
    def translation_detail(self, request, language, *args, **kwargs):
        obj = self._check_translation(language)
        if not obj:
            return Response(status=status.HTTP_404_NOT_FOUND)
        if request.method.lower() == 'get':
            serializer = VulnerabilityTemplateTranslationSerializer(obj)
        elif request.method.lower() == 'patch':
            serializer = VulnerabilityTemplateTranslationPatchSerializer(obj, data=request.data)
            serializer.is_valid(raise_exception=True)
            serializer.save()
        elif request.method.lower() == 'delete':
            obj.delete()
            return Response(status=status.HTTP_204_NO_CONTENT)
        else:
            return Response(status=status.HTTP_404_NOT_FOUND)
        return Response(serializer.data, status=status.HTTP_200_OK)

    def _check_translation(self, language):
        """
        return None, if we should return 404 in translation views.
        Otherwise, return translation object
        """
        template = self.get_object()
        valid_languages = [x[0] for x in settings.LANGUAGES]
        if language not in valid_languages:
            return None
        translation = models.VulnerabilityTemplateTranslation.objects.for_template(template).for_language(language)
        try:
            obj = translation.get()
            return obj
        except models.VulnerabilityTemplateTranslation.DoesNotExist:
            return None


@schema.extend_viewset_schema(tags=['Vulnerabilities'], verbose_name='project vulnerability',
                              verbose_name_plural='project vulnerabilities')
@extend_schema_view(search=extend_schema(tags=['Vulnerabilities'], operation_id='Search project vulnerabilities'))
class ProjectVulnerabilityViewSet(PeCoReTModelViewSet):
    queryset = models.ProjectVulnerability.objects.none()
    search_fields = ["vulnerability_id", "name"]
    filterset_class = None
    serializer_class = ProjectVulnerabilitySerializer
    permission_classes = [permissions.PRESET_PENTESTER_OR_READONLY]
    api_scope = 'scope_all_projects'

    def get_queryset(self):
        return models.ProjectVulnerability.objects.for_project(self.request.project)

    def perform_create(self, serializer):
        serializer.save(project=self.request.project)

    @action(detail=False, methods=["get"])
    def search(self, request, project, pk=None):
        search_filter = SearchFilter()
        project_vulnerabilities = search_filter.filter_queryset(
            request,
            self.get_queryset(),
            self,
        )
        available_templates = search_filter.filter_queryset(
            request,
            models.VulnerabilityTemplate.objects.exclude(
                vulnerability_id__in=project_vulnerabilities.values_list(
                    "vulnerability_id", flat=True
                )
            ),
            self,
        )
        project_vuln_serializer = ProjectVulnerabilitySerializer(project_vulnerabilities, many=True)
        template_vuln_serializer = ProjectVulnerabilitySerializer(available_templates, many=True)
        full_data = project_vuln_serializer.data + template_vuln_serializer.data
        return Response(data={"results": full_data})
